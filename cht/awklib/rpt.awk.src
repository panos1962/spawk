#!/bin/awk

#
# Το παρόν file περιέχει το default action (detail) του chtawkrpt.
# Εδώ ελέγχεται κάθε γραμμή του πρωτογενούς input και εκτελούνται
# οι πρέπουσες ενέργειες.
#
# Ο λόγος για τον οποίο το default action δεν είναι γραμμένο στο
# file `chtrptlib.awk.src' έχει να κάνει με τη σειρά εκτέλεσης
# των actions από τον awk. Με τον τρόπο αυτό μπορώ να γράφω
# actions στο `functions' section οι οποίες θα εκτελούνται πριν
# το παρόν default action. Αν πάλι η βιβλιοθήκη ακολουθούσε ως
# τελευταία στο awk command line, θα είχαμε αντίθετο πρόβλημα
# με τα BEGIN sections· δεν θα μπορούσαμε να θέσουμε τιμές σε
# διάφορες μεταβλητές, καθώς τα BEGIN sections της βιβλιοθήκης
# θα έτρεχαν μετά τις όποιες δικές μας εντολές.
#

{
	# Πρώτα ελέγχεται το input record όσον αφορά στην ίδια τη
	# φύση και τη δομή του: Ελέγχεται αν πρόκειται για control
	# data (end-of-data mark) και, εφόσον πρόκειται για data
	# record, ελέγχεται το πλήθος και η ορθότητα των πεδίων.
	# Επίσης, μέσα από την `cht_rpt_check_data' τίθεται η flag
	# `cht_rpt_subreport' που δείχνει αν είμαστε σε subreport
	# και αν ναι σε ποιά φάση  βρισκόμαστε:
	#
	# 1: παραλαβή δεδομένων
	# 2: τέλος data set

	if (cht_rpt_check_data()) {
		cht_rpt_return_data()
		next
	}

	# Τρέχω τον `input' κώδικα και εφόσον δεν έχω sort fields
	# κάνω απευθείας διαχείριση του input καλώντας απευθείας
	# τη `cht_rpt_detail_code' function αντί της
	# `cht_rpt_process_data' εφόσον δεν θα τρέξει κανένας
	# `before/after' κώδικας. Υπενθυμίζουμε ότι, ακόμη και
	# αν το input record έχει περάσει τους default ελέγχους,
	# μπορώ να το απορρίψω (reject) μέσω του `input' κώδικα
	# δίνοντας (μέσα στον `input' κώδικα) return(1). Αντίθετα,
	# μπορώ να δεχθώ να δεχθώ (accept) το record διακόπτοντας
	# την εκτέλση του `input' κώδικα δίνοντας return(0). Αν
	# δεν έχω διακοπή (με return) μέσα στον `input' κώδικα,
	# τότε αυτός εκτελείται ολόκληρος και κατόπιν εκτελείται
	# αυτόματα return(0) (οπότε το record γίνεται αποδεκτό).

	if (cht_rpt_input_code()) {
		cht_rpt_return_data()
		next
	}

	# Είμαι στη φάση που το input record έχει περάσει όλους
	# τους ελέγχους και έχει γίνει αποδεκτό μέσω του `input'
	# κώδικα. Ελέγχω λοιπόν αν είναι το πρώτο record που
	# διαχειρίζομαι στο τρέχον data set και, αν είναι έτσι,
	# εκτελώ τον `before set' κώδικα.

	if (cht_rpt_data_line++ == -1) {
		if (!cht_rpt_accepted_data++)
			cht_rpt_before_accepted_code()

		cht_rpt_before_data_code()
		cht_rpt_data_line = 1
	}

	# Όπως είπαμε παραπάνω, αν δεν έχω sort, προχωρώ αμέσως
	# στην εκτέλεση του `detail' κώδικα, εφόσον δεν θα
	# εκτελεστεί κανένας `before/after' κώδικας που αφορά
	# σε αλλαγή τιμών.

	if (!cht_rpt_sort_count) {
		cht_rpt_detail_code()
		cht_rpt_return_data()
		next
	}

	# Αν έχω sort fields πρέπει να κάνω ό,τι χρειάζεται για
	# το sort: Αν υπάρχει πραγματική ανάγκη ταξινόμησης στέλνω
	# τα δεδομένα για ταξινόμηση και θα τα παραλάβω αργότερα.
	# Αν δεν υπάρχει πραγματική ανάγκη ταξινόμησης κάνω τώρα
	# διαχείριση του δευτερογενούς (υποτίθεται) input. Η function
	# `cht_rpt_sort_send' θα μου επιστρέψει μη μηδενική τιμή
	# εφόσον δεν υπάρχει πραγματική ανάγκη ταξινόμησης, αλλιώς
	# επιστρέφει μηδέν.

	if (cht_rpt_sort_send())
		cht_rpt_process_data()

	cht_rpt_return_data()
}
